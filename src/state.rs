use serde::{Deserialize, Serialize};
use std::{collections::HashMap, sync::Arc};
use tokio::sync::RwLock;

// `Store` is the in-memory mapping store shared across handlers. It wraps
// a `HashMap` keyed by the compound `manufacturer::sensor_id` generated by
// `key_for` so lookups/updates are O(1) under the lock.
pub type Store = Arc<RwLock<HashMap<String, Mapping>>>;

// `Mapping` is the JSON structure accepted by the `/mapping` endpoint.
// Keep it simple: a sensor id, manufacturer and a human-readable name.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Mapping {
    pub sensor_id: String,
    pub manufacturer: String,
    pub name: String,
}

// File used as a simple placeholder persistence layer. When you migrate to
// DuckDB/DuckLake, replace `load_mappings`/`save_mappings` implementations
// with queries against the DB and remove this file-based path.
pub const MAPPINGS_FILE: &str = "mappings.json";

/// Load mappings from disk. Returns an empty map if the file does not exist.
/// This is intentionally simple and synchronous-looking (async fs) so the
/// rest of the code can await it during startup.
pub async fn load_mappings() -> anyhow::Result<HashMap<String, Mapping>> {
    match tokio::fs::read_to_string(MAPPINGS_FILE).await {
        Ok(raw) => {
            let v: Vec<Mapping> = serde_json::from_str(&raw)?;
            let map = v
                .into_iter()
                .map(|m| (key_for(&m.sensor_id, &m.manufacturer), m))
                .collect();
            Ok(map)
        }
        Err(_) => Ok(HashMap::new()),
    }
}

/// Persist mappings to disk. This is called after updates so state survives
/// process restarts. If you move to a DB, ensure writes are transactional
/// and consider batching for throughput.
pub async fn save_mappings(store: &Store) -> anyhow::Result<()> {
    let map = store.read().await;
    let vec: Vec<Mapping> = map.values().cloned().collect();
    let raw = serde_json::to_string_pretty(&vec)?;
    tokio::fs::write(MAPPINGS_FILE, raw).await?;
    Ok(())
}

/// Compose a key for the internal HashMap. The format is `manufacturer::id`.
/// This keeps keys unique across different manufacturers and is reversible
/// if you need to split them later.
pub fn key_for(sensor_id: &str, manufacturer: &str) -> String {
    format!("{}::{}", manufacturer, sensor_id)
}
